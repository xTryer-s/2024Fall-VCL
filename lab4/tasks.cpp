#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <spdlog/spdlog.h>
#include <iostream>
#include "Labs/4-Animation/tasks.h"
#include "IKSystem.h"
#include "CustomFunc.inl"


namespace VCX::Labs::Animation {
    void ForwardKinematics(IKSystem & ik, int StartIndex) {
        if (StartIndex == 0) {
            ik.JointGlobalRotation[0] = ik.JointLocalRotation[0];
            ik.JointGlobalPosition[0] = ik.JointLocalOffset[0];
            StartIndex                = 1;
        }
        
        for (int i = StartIndex; i < ik.JointLocalOffset.size(); i++) {
            // your code here: forward kinematics, update JointGlobalPosition and JointGlobalRotation
            ik.JointGlobalRotation[i] = glm::normalize(glm::normalize(ik.JointGlobalRotation[i - 1])*glm::normalize(ik.JointLocalRotation[i]));
            glm::vec4 global_offset   = ik.JointGlobalRotation[i - 1] * glm::vec4(ik.JointLocalOffset[i], 1.0);
            ik.JointGlobalPosition[i] = ik.JointGlobalPosition[i - 1] + glm::vec3(global_offset);
        }
    }

    void InverseKinematicsCCD(IKSystem & ik, const glm::vec3 & EndPosition, int maxCCDIKIteration, float eps) {
        ForwardKinematics(ik, 0);
        // These functions will be useful: glm::normalize, glm::rotation, glm::quat * glm::quat
        for (int CCDIKIteration = 0; CCDIKIteration < maxCCDIKIteration && glm::l2Norm(ik.EndEffectorPosition() - EndPosition) > eps; CCDIKIteration++) {
            // your code here: ccd ik
            for (int i = ik.NumJoints() - 1; i >= 0; i--)
            {
                glm::vec3 cur_joint_pos = ik.JointGlobalPosition[i];
                glm::vec3 end_effector_pos = ik.EndEffectorPosition();

                glm::vec3 cur_to_tar = glm::normalize(EndPosition - cur_joint_pos);
                glm::vec3 cur_to_effect = glm::normalize(end_effector_pos - cur_joint_pos);


                glm::quat rotation_quat = glm::rotation(cur_to_effect,cur_to_tar);
                ik.JointLocalRotation[i] = rotation_quat * ik.JointLocalRotation[i];

                ForwardKinematics(ik, i);


            }
            //printf("IK-CCD cur-iteration:%d,Max_iteration_limit:%d\n",CCDIKIteration,maxCCDIKIteration);
        }
        
    }

    void InverseKinematicsFABR(IKSystem & ik, const glm::vec3 & EndPosition, int maxFABRIKIteration, float eps) {
        ForwardKinematics(ik, 0);
        int nJoints = ik.NumJoints();
        std::vector<glm::vec3> backward_positions(nJoints, glm::vec3(0, 0, 0)), forward_positions(nJoints, glm::vec3(0, 0, 0));
        for (int IKIteration = 0; IKIteration < maxFABRIKIteration && glm::l2Norm(ik.EndEffectorPosition() - EndPosition) > eps; IKIteration++) {
            // task: fabr ik
            // backward update
            glm::vec3 next_position         = EndPosition;
            backward_positions[nJoints - 1] = EndPosition;

            for (int i = nJoints - 2; i >= 0; i--) {
                // your code here
                glm::vec3 normalized_dir = glm::normalize(ik.JointGlobalPosition[i] - next_position);
                backward_positions[i]    = next_position + normalized_dir * glm::length(ik.JointLocalOffset[i + 1]);
                next_position            = backward_positions[i];
            }

            // forward update
            glm::vec3 now_position = ik.JointGlobalPosition[0];
            forward_positions[0] = ik.JointGlobalPosition[0];
            for (int i = 0; i < nJoints - 1; i++) {
                // your code here
                glm::vec3 normalized_dir = glm::normalize(backward_positions[i + 1] - now_position);
                forward_positions[i + 1] = now_position + normalized_dir * glm::length(ik.JointLocalOffset[i + 1]);
                now_position             = forward_positions[i + 1];
            }
            ik.JointGlobalPosition = forward_positions; // copy forward positions to joint_positions
            //printf("IK-FABR cur-iteration:%d,Max_iteration_limit:%d\n", IKIteration,maxFABRIKIteration);
        }

        // Compute joint rotation by position here.
        for (int i = 0; i < nJoints - 1; i++) {
            ik.JointGlobalRotation[i] = glm::rotation(glm::normalize(ik.JointLocalOffset[i + 1]), glm::normalize(ik.JointGlobalPosition[i + 1] - ik.JointGlobalPosition[i]));
        }
        ik.JointLocalRotation[0] = ik.JointGlobalRotation[0];
        for (int i = 1; i < nJoints - 1; i++) {
            ik.JointLocalRotation[i] = glm::inverse(ik.JointGlobalRotation[i - 1]) * ik.JointGlobalRotation[i];
        }
        ForwardKinematics(ik, 0);
    }

    float doge_custom_x(float t) {
        float x_t = ((-35.0 / 11 * sin(11.0 / 7 - 4 * t) - 8.0 / 9 * sin(11.0 / 7 - 3 * t) - 127.0 / 10 * sin(11.0 / 7 - 2 * t) + 58.0 / 9 * sin(t + 33.0 / 7) - 209.0 / 8) * theta(99 * EIGEN_PI - t) * theta(t - 95 * EIGEN_PI) + (-8.0 / 17 * sin(3.0 / 2 - 2 * t) + 335.0 / 4 * sin(t + 11.0 / 7) + 77.0 / 10 * sin(3 * t + 11.0 / 7) + 3.0 / 8 * sin(4 * t + 17.0 / 11) + 23.0 / 10 * sin(5 * t + 11.0 / 7) + 3.0 / 7 * sin(6 * t + 11.0 / 7) + 13.0 / 11 * sin(7 * t + 11.0 / 7) + 1.0 / 6 * sin(8 * t + 19.0 / 12) + 7.0 / 10 * sin(9 * t + 14.0 / 9) + 1.0 / 30 * sin(10 * t + 59.0 / 13) - 209.0 / 12) * theta(95 * EIGEN_PI - t) * theta(t - 91 * EIGEN_PI) + (-8.0 / 15 * sin(11.0 / 7 - 5 * t) - 4.0 / 3 * sin(11.0 / 7 - 3 * t) - 57.0 / 29 * sin(11.0 / 7 - t) + 12.0 / 7 * sin(2 * t + 11.0 / 7) + 9.0 / 10 * sin(4 * t + 11.0 / 7) - 686.0 / 13) * theta(91 * EIGEN_PI - t) * theta(t - 87 * EIGEN_PI) + (-3.0 / 2 * sin(11.0 / 7 - 4 * t) + 67.0 / 9 * sin(t + 11.0 / 7) + 14.0 / 11 * sin(2 * t + 33.0 / 7) + 17.0 / 13 * sin(3 * t + 11.0 / 7) + 9.0 / 13 * sin(5 * t + 11.0 / 7) + 2380.0 / 11) * theta(87 * EIGEN_PI - t) * theta(t - 83 * EIGEN_PI) + (-1.0 / 18 * sin(11.0 / 8 - 22 * t) - 2.0 / 9 * sin(17.0 / 11 - 19 * t) - 3.0 / 14 * sin(14.0 / 9 - 17 * t) - 11.0 / 10 * sin(20.0 / 13 - 13 * t) - 6.0 / 7 * sin(20.0 / 13 - 10 * t) - 7.0 / 8 * sin(11.0 / 7 - 2 * t) + sin(t + 11.0 / 7) + 1.0 / 6 * sin(3 * t + 11.0 / 7) + 13.0 / 10 * sin(4 * t + 19.0 / 12) + 4.0 / 5 * sin(5 * t + 19.0 / 12) + 2.0 / 3 * sin(6 * t + 19.0 / 12) + 23.0 / 22 * sin(7 * t + 8.0 / 5) + 1.0 / 8 * sin(8 * t + 47.0 / 10) + 4.0 / 7 * sin(9 * t + 8.0 / 5) + 7.0 / 8 * sin(11 * t + 21.0 / 13) + sin(12 * t + 8.0 / 5) + 5.0 / 11 * sin(14 * t + 8.0 / 5) + 3.0 / 14 * sin(15 * t + 33.0 / 7) + 1.0 / 48 * sin(16 * t + 11.0 / 9) + 1.0 / 5 * sin(18 * t + 21.0 / 13) + 1.0 / 11 * sin(20 * t + 17.0 / 11) + 1.0 / 43 * sin(21 * t + 9.0 / 2) - 636.0 / 5) * theta(83 * EIGEN_PI - t) * theta(t - 79 * EIGEN_PI) + (-3.0 / 2 * sin(16.0 / 11 - 22 * t) - 1.0 / 4 * sin(17.0 / 11 - 21 * t) - 1.0 / 7 * sin(14.0 / 9 - 14 * t) - 9.0 / 13 * sin(20.0 / 13 - 10 * t) - 4.0 / 7 * sin(11.0 / 7 - 8 * t) - 1.0 / 23 * sin(15.0 / 11 - 7 * t) - 3.0 / 11 * sin(11.0 / 7 - 6 * t) - 1.0 / 16 * sin(17.0 / 11 - 5 * t) + 53.0 / 9 * sin(t + 11.0 / 7) + 25.0 / 7 * sin(2 * t + 11.0 / 7) + 4.0 / 3 * sin(3 * t + 19.0 / 12) + 7.0 / 13 * sin(4 * t + 11.0 / 7) + 5.0 / 9 * sin(9 * t + 11.0 / 7) + 18.0 / 19 * sin(11 * t + 13.0 / 8) + 28.0 / 19 * sin(12 * t + 18.0 / 11) + 5.0 / 6 * sin(13 * t + 13.0 / 8) + 27.0 / 28 * sin(15 * t + 18.0 / 11) + 60.0 / 59 * sin(16 * t + 13.0 / 8) + 1.0 / 3 * sin(17 * t + 37.0 / 8) + 32.0 / 19 * sin(18 * t + 8.0 / 5) + 7.0 / 11 * sin(19 * t + 61.0 / 13) + 7.0 / 5 * sin(20 * t + 13.0 / 8) - 1073.0 / 12) * theta(79 * EIGEN_PI - t) * theta(t - 75 * EIGEN_PI) + (-1.0 / 10 * sin(10.0 / 7 - 45 * t) - 1.0 / 9 * sin(16.0 / 11 - 44 * t) - 1.0 / 80 * sin(2.0 / 5 - 41 * t) - 1.0 / 5 * sin(3.0 / 2 - 40 * t) - 1.0 / 10 * sin(10.0 / 7 - 37 * t) - 1.0 / 7 * sin(3.0 / 2 - 34 * t) - 1.0 / 5 * sin(22.0 / 15 - 31 * t) - 8.0 / 11 * sin(20.0 / 13 - 30 * t) - 3.0 / 8 * sin(20.0 / 13 - 26 * t) - 6.0 / 11 * sin(3.0 / 2 - 23 * t) - 3.0 / 7 * sin(19.0 / 13 - 20 * t) - 4.0 / 9 * sin(3.0 / 2 - 19 * t) - 3.0 / 2 * sin(20.0 / 13 - 16 * t) - 2.0 / 11 * sin(23.0 / 15 - 15 * t) - 21.0 / 13 * sin(14.0 / 9 - 13 * t) - 14.0 / 15 * sin(3.0 / 2 - 12 * t) - 65.0 / 11 * sin(14.0 / 9 - 9 * t) - 12.0 / 11 * sin(3.0 / 2 - 6 * t) - 77.0 / 5 * sin(14.0 / 9 - 5 * t) - 674.0 / 15 * sin(11.0 / 7 - 2 * t) - 64.0 / 5 * sin(11.0 / 7 - t) + 527.0 / 24 * sin(3 * t + 11.0 / 7) + 165.0 / 7 * sin(4 * t + 11.0 / 7) + 131.0 / 26 * sin(7 * t + 8.0 / 5) + 11.0 / 9 * sin(8 * t + 11.0 / 7) + 25.0 / 13 * sin(10 * t + 19.0 / 12) + 2.0 / 7 * sin(11 * t + 5.0 / 3) + 26.0 / 17 * sin(14 * t + 21.0 / 13) + 2.0 / 13 * sin(17 * t + 60.0 / 13) + 8.0 / 11 * sin(18 * t + 18.0 / 11) + 19.0 / 20 * sin(21 * t + 13.0 / 8) + 7.0 / 11 * sin(22 * t + 13.0 / 8) + 1.0 / 7 * sin(24 * t + 14.0 / 9) + 1.0 / 7 * sin(25 * t + 13.0 / 8) + 2.0 / 13 * sin(27 * t + 11.0 / 7) + 7.0 / 12 * sin(28 * t + 21.0 / 13) + 6.0 / 11 * sin(29 * t + 8.0 / 5) + 1.0 / 8 * sin(32 * t + 5.0 / 3) + 1.0 / 15 * sin(33 * t + 65.0 / 14) + 1.0 / 5 * sin(35 * t + 8.0 / 5) + 2.0 / 9 * sin(36 * t + 13.0 / 8) + 2.0 / 13 * sin(38 * t + 47.0 / 10) + 1.0 / 10 * sin(39 * t + 19.0 / 11) + 1.0 / 9 * sin(42 * t + 19.0 / 11) + 2.0 / 7 * sin(43 * t + 18.0 / 11) + 1.0 / 25 * sin(46 * t + 47.0 / 10) - 1042.0 / 7) * theta(75 * EIGEN_PI - t) * theta(t - 71 * EIGEN_PI) + (-1.0 / 25 * sin(20.0 / 19 - 37 * t) - 2.0 / 9 * sin(13.0 / 9 - 36 * t) - 5.0 / 13 * sin(31.0 / 21 - 32 * t) - 3.0 / 13 * sin(23.0 / 15 - 28 * t) - 1.0 / 35 * sin(1.0 / 63 - 27 * t) - 1.0 / 9 * sin(4.0 / 3 - 23 * t) - 7.0 / 11 * sin(3.0 / 2 - 22 * t) - 2.0 / 3 * sin(17.0 / 11 - 18 * t) - 12.0 / 7 * sin(38.0 / 25 - 9 * t) - 52.0 / 9 * sin(17.0 / 11 - 8 * t) - 317.0 / 6 * sin(11.0 / 7 - 2 * t) + 679.0 / 9 * sin(t + 11.0 / 7) + 342.0 / 7 * sin(3 * t + 19.0 / 12) + 161.0 / 10 * sin(4 * t + 8.0 / 5) + 65.0 / 6 * sin(5 * t + 8.0 / 5) + 13.0 / 7 * sin(6 * t + 13.0 / 8) + 38.0 / 5 * sin(7 * t + 8.0 / 5) + 10.0 / 9 * sin(10 * t + 23.0 / 14) + 34.0 / 9 * sin(11 * t + 8.0 / 5) + 11.0 / 12 * sin(12 * t + 33.0 / 7) + 2.0 / 11 * sin(13 * t + 13.0 / 9) + 1.0 / 2 * sin(14 * t + 7.0 / 4) + 19.0 / 9 * sin(15 * t + 13.0 / 8) + 3.0 / 8 * sin(16 * t + 19.0 / 11) + 10.0 / 11 * sin(17 * t + 8.0 / 5) + 11.0 / 16 * sin(19 * t + 13.0 / 8) + 26.0 / 25 * sin(20 * t + 17.0 / 10) + 22.0 / 23 * sin(21 * t + 13.0 / 8) + 5.0 / 9 * sin(24 * t + 12.0 / 7) + 32.0 / 33 * sin(25 * t + 5.0 / 3) + 1.0 / 43 * sin(26 * t + 31.0 / 9) + 5.0 / 11 * sin(29 * t + 22.0 / 13) + 3.0 / 8 * sin(30 * t + 19.0 / 11) + 3.0 / 13 * sin(31 * t + 5.0 / 3) + 2.0 / 13 * sin(33 * t + 21.0 / 13) + 3.0 / 7 * sin(34 * t + 7.0 / 4) + 3.0 / 8 * sin(35 * t + 19.0 / 11) + 1.0 / 10 * sin(38 * t + 11.0 / 6) + 1520.0 / 11) * theta(71 * EIGEN_PI - t) * theta(t - 67 * EIGEN_PI) + (-7.0 / 15 * sin(14.0 / 9 - 13 * t) - 1.0 / 16 * sin(23.0 / 15 - 12 * t) - 3.0 / 4 * sin(11.0 / 7 - 10 * t) - 3.0 / 4 * sin(14.0 / 9 - 9 * t) - 5.0 / 9 * sin(11.0 / 7 - 8 * t) - 24.0 / 11 * sin(11.0 / 7 - 6 * t) - 2.0 / 5 * sin(14.0 / 9 - 5 * t) - 373.0 / 20 * sin(11.0 / 7 - 2 * t) - 2.0 / 3 * sin(14.0 / 9 - t) + 25.0 / 7 * sin(3 * t + 11.0 / 7) + 23.0 / 8 * sin(4 * t + 11.0 / 7) + 6.0 / 11 * sin(7 * t + 14.0 / 9) + 1.0 / 2 * sin(11 * t + 11.0 / 7) + 60.0 / 7) * theta(67 * EIGEN_PI - t) * theta(t - 63 * EIGEN_PI) + (-3.0 / 11 * sin(17.0 / 11 - 26 * t) - 1.0 / 9 * sin(14.0 / 9 - 25 * t) - 1.0 / 18 * sin(7.0 / 5 - 23 * t) - 7.0 / 9 * sin(14.0 / 9 - 20 * t) - 16.0 / 15 * sin(17.0 / 11 - 19 * t) - 2.0 / 5 * sin(19.0 / 13 - 11 * t) - 15.0 / 8 * sin(14.0 / 9 - 10 * t) - 3.0 / 4 * sin(17.0 / 11 - 5 * t) - 21.0 / 4 * sin(14.0 / 9 - 4 * t) + 133.0 / 9 * sin(t + 11.0 / 7) + 31.0 / 7 * sin(2 * t + 11.0 / 7) + 51.0 / 2 * sin(3 * t + 11.0 / 7) + 5.0 / 8 * sin(6 * t + 17.0 / 11) + 13.0 / 6 * sin(7 * t + 11.0 / 7) + 7.0 / 13 * sin(8 * t + 14.0 / 9) + 49.0 / 12 * sin(9 * t + 19.0 / 12) + 7.0 / 8 * sin(12 * t + 8.0 / 5) + 6.0 / 7 * sin(13 * t + 11.0 / 7) + 2.0 / 9 * sin(14 * t + 51.0 / 11) + 3.0 / 4 * sin(15 * t + 17.0 / 11) + 1.0 / 34 * sin(16 * t + 79.0 / 20) + 8.0 / 15 * sin(17 * t + 21.0 / 13) + 1.0 / 21 * sin(18 * t + 12.0 / 7) + 1.0 / 5 * sin(21 * t + 47.0 / 10) + 3.0 / 5 * sin(22 * t + 33.0 / 7) + 1.0 / 42 * sin(24 * t + 13.0 / 6) + 3.0 / 10 * sin(27 * t + 19.0 / 12) + 1.0 / 25 * sin(28 * t + 13.0 / 8) + 1076.0 / 7) * theta(63 * EIGEN_PI - t) * theta(t - 59 * EIGEN_PI) + (-1.0 / 19 * sin(7.0 / 5 - 20 * t) - 1.0 / 32 * sin(8.0 / 7 - 15 * t) - 5.0 / 7 * sin(25.0 / 17 - 14 * t) - 16.0 / 31 * sin(16.0 / 11 - 13 * t) - 1.0 / 16 * sin(4.0 / 5 - 12 * t) - 17.0 / 10 * sin(23.0 / 15 - 11 * t) - 3.0 / 4 * sin(28.0 / 19 - 3 * t) - 191.0 / 24 * sin(11.0 / 7 - 2 * t) + 280.0 / 9 * sin(t + 11.0 / 7) + 2.0 / 11 * sin(4 * t + 8.0 / 5) + 11.0 / 5 * sin(5 * t + 13.0 / 8) + 20.0 / 11 * sin(6 * t + 18.0 / 11) + 18.0 / 7 * sin(7 * t + 13.0 / 8) + 17.0 / 13 * sin(8 * t + 23.0 / 14) + 5.0 / 9 * sin(9 * t + 33.0 / 7) + 1.0 / 2 * sin(10 * t + 3.0 / 2) + 3.0 / 10 * sin(16 * t + 5.0 / 3) + 3.0 / 11 * sin(17 * t + 19.0 / 11) + 1.0 / 6 * sin(18 * t + 12.0 / 7) + 1.0 / 6 * sin(19 * t + 23.0 / 14) + 523.0 / 2) * theta(59 * EIGEN_PI - t) * theta(t - 55 * EIGEN_PI) + (-1.0 / 6 * sin(20.0 / 13 - 26 * t) - 8.0 / 15 * sin(11.0 / 7 - 16 * t) - 1.0 / 6 * sin(19.0 / 14 - 14 * t) - 1.0 / 10 * sin(13.0 / 9 - 12 * t) - 4 * sin(14.0 / 9 - 6 * t) + 811.0 / 11 * sin(t + 11.0 / 7) + 508.0 / 11 * sin(2 * t + 33.0 / 7) + 57.0 / 4 * sin(3 * t + 11.0 / 7) + 32.0 / 21 * sin(4 * t + 3.0 / 2) + 59.0 / 6 * sin(5 * t + 11.0 / 7) + 2.0 / 7 * sin(7 * t + 9.0 / 2) + 29.0 / 8 * sin(8 * t + 75.0 / 16) + 18.0 / 7 * sin(9 * t + 14.0 / 3) + 31.0 / 9 * sin(10 * t + 61.0 / 13) + 3.0 / 5 * sin(11 * t + 13.0 / 8) + 7.0 / 8 * sin(13 * t + 14.0 / 9) + 9.0 / 11 * sin(15 * t + 19.0 / 12) + 1.0 / 5 * sin(17 * t + 5.0 / 3) + 1.0 / 4 * sin(18 * t + 55.0 / 12) + 3.0 / 11 * sin(19 * t + 23.0 / 5) + 7.0 / 9 * sin(20 * t + 79.0 / 17) + 3.0 / 11 * sin(21 * t + 41.0 / 9) + 5.0 / 7 * sin(22 * t + 65.0 / 14) + 2.0 / 9 * sin(23 * t + 50.0 / 11) + 2.0 / 5 * sin(24 * t + 79.0 / 17) + 1.0 / 6 * sin(25 * t + 22.0 / 13) + 1.0 / 19 * sin(27 * t + 5.0 / 3) + 1.0 / 14 * sin(28 * t + 13.0 / 8) + 1.0 / 5 * sin(29 * t + 17.0 / 11) + 2.0 / 9 * sin(30 * t + 51.0 / 11) + 1.0 / 23 * sin(31 * t + 37.0 / 9) + 3.0 / 11 * sin(32 * t + 23.0 / 5) + 1.0 / 27 * sin(33 * t + 49.0 / 12) + 3.0 / 10 * sin(34 * t + 14.0 / 3) + 1.0 / 16 * sin(35 * t + 17.0 / 4) + 1.0 / 29 * sin(36 * t + 49.0 / 11) + 1.0 / 11 * sin(37 * t + 58.0 / 13) + 2.0 / 5 * sin(38 * t + 23.0 / 5) + 1.0 / 23 * sin(39 * t + 46.0 / 11) + 1.0 / 9 * sin(40 * t + 94.0 / 21) + 1.0 / 34 * sin(41 * t + 55.0 / 13) + 1.0 / 11 * sin(42 * t + 33.0 / 7) + 1.0 / 6 * sin(43 * t + 14.0 / 9) + 1549.0 / 9) * theta(55 * EIGEN_PI - t) * theta(t - 51 * EIGEN_PI) + (158.0 / 9 * sin(t + 11.0 / 7) + 15.0 / 8 * sin(2 * t + 11.0 / 7) + 20.0 / 9 * sin(3 * t + 11.0 / 7) - 334.0 / 11) * theta(51 * EIGEN_PI - t) * theta(t - 47 * EIGEN_PI) + (-1.0 / 10 * sin(9.0 / 11 - 22 * t) - 3.0 / 13 * sin(10.0 / 7 - 20 * t) - 2.0 / 13 * sin(11.0 / 7 - 17 * t) + 927.0 / 16 * sin(t + 33.0 / 7) + 327.0 / 13 * sin(2 * t + 33.0 / 7) + 337.0 / 9 * sin(3 * t + 14.0 / 9) + 62.0 / 5 * sin(4 * t + 17.0 / 11) + 67.0 / 12 * sin(5 * t + 47.0 / 10) + 73.0 / 21 * sin(6 * t + 20.0 / 13) + 49.0 / 48 * sin(7 * t + 14.0 / 9) + 4 * sin(8 * t + 14.0 / 3) + 4.0 / 11 * sin(9 * t + 8.0 / 5) + 1.0 / 8 * sin(10 * t + 27.0 / 16) + 26.0 / 11 * sin(11 * t + 55.0 / 12) + 88.0 / 25 * sin(12 * t + 79.0 / 17) + 2 * sin(13 * t + 14.0 / 9) + 20.0 / 11 * sin(14 * t + 79.0 / 17) + 4.0 / 11 * sin(15 * t + 103.0 / 23) + 9.0 / 7 * sin(16 * t + 28.0 / 19) + 5.0 / 11 * sin(18 * t + 14.0 / 3) + 11.0 / 17 * sin(19 * t + 3.0 / 2) + 2.0 / 7 * sin(21 * t + 8.0 / 5) + 11.0 / 9 * sin(23 * t + 22.0 / 15) + 7.0 / 11 * sin(24 * t + 47.0 / 10) + 3.0 / 13 * sin(25 * t + 34.0 / 23) + 3.0 / 8 * sin(26 * t + 11.0 / 8) + 1.0 / 7 * sin(27 * t + 47.0 / 10) + 1.0 / 13 * sin(28 * t + 17.0 / 13) + 2.0 / 11 * sin(29 * t + 11.0 / 7) + 1.0 / 3 * sin(30 * t + 37.0 / 8) + 1.0 / 22 * sin(31 * t + 48.0 / 13) + 1.0 / 6 * sin(32 * t + 37.0 / 8) - 575.0 / 7) * theta(47 * EIGEN_PI - t) * theta(t - 43 * EIGEN_PI) + (-1.0 / 7 * sin(14.0 / 9 - 7 * t) - 1.0 / 13 * sin(3.0 / 2 - 6 * t) - 11.0 / 13 * sin(14.0 / 9 - 5 * t) - 5.0 / 16 * sin(32.0 / 21 - 4 * t) - 11.0 / 6 * sin(11.0 / 7 - 3 * t) - 6.0 / 5 * sin(14.0 / 9 - 2 * t) - 215.0 / 9 * sin(11.0 / 7 - t) - 464.0 / 5) * theta(43 * EIGEN_PI - t) * theta(t - 39 * EIGEN_PI) + (739.0 / 12 * sin(t + 11.0 / 7) + 45.0 / 11 * sin(2 * t + 11.0 / 7) + 24.0 / 7 * sin(3 * t + 11.0 / 7) + 33.0 / 14 * sin(4 * t + 11.0 / 7) + 7.0 / 9 * sin(5 * t + 14.0 / 9) + 14.0 / 11 * sin(6 * t + 11.0 / 7) + 5.0 / 9 * sin(7 * t + 14.0 / 9) + 5.0 / 8 * sin(8 * t + 17.0 / 11) + 3.0 / 13 * sin(9 * t + 3.0 / 2) + 3.0 / 5 * sin(10 * t + 11.0 / 7) + 3.0 / 13 * sin(11 * t + 14.0 / 9) + 3.0 / 10 * sin(12 * t + 14.0 / 9) + 2.0 / 11 * sin(13 * t + 14.0 / 9) + 1.0 / 6 * sin(14 * t + 14.0 / 9) - 545.0 / 7) * theta(39 * EIGEN_PI - t) * theta(t - 35 * EIGEN_PI) + (-1.0 / 70 * sin(16.0 / 11 - 34 * t) - 1.0 / 4 * sin(3.0 / 2 - 30 * t) - 3.0 / 11 * sin(26.0 / 17 - 29 * t) - 1.0 / 23 * sin(10.0 / 7 - 28 * t) - 4.0 / 11 * sin(38.0 / 25 - 25 * t) - 1.0 / 5 * sin(3.0 / 2 - 24 * t) - 1.0 / 7 * sin(19.0 / 13 - 20 * t) - 9.0 / 10 * sin(23.0 / 15 - 19 * t) - 2.0 / 9 * sin(13.0 / 9 - 18 * t) - 5.0 / 12 * sin(26.0 / 17 - 14 * t) - 13.0 / 8 * sin(20.0 / 13 - 13 * t) - 25.0 / 13 * sin(14.0 / 9 - 9 * t) - 19.0 / 7 * sin(20.0 / 13 - 8 * t) - 31.0 / 7 * sin(14.0 / 9 - 7 * t) - 355.0 / 13 * sin(11.0 / 7 - 3 * t) - 155.0 / 3 * sin(11.0 / 7 - 2 * t) + 503.0 / 11 * sin(t + 11.0 / 7) + 7.0 / 8 * sin(4 * t + 65.0 / 14) + 4.0 / 3 * sin(5 * t + 33.0 / 7) + 40.0 / 9 * sin(6 * t + 11.0 / 7) + 5.0 / 7 * sin(10 * t + 21.0 / 13) + 1.0 / 4 * sin(11 * t + 17.0 / 10) + 3.0 / 14 * sin(12 * t + 11.0 / 7) + 10.0 / 13 * sin(15 * t + 33.0 / 7) + 8.0 / 9 * sin(16 * t + 21.0 / 13) + 3.0 / 8 * sin(17 * t + 47.0 / 10) + 1.0 / 76 * sin(21 * t + 80.0 / 23) + 2.0 / 11 * sin(22 * t + 18.0 / 11) + 6.0 / 17 * sin(23 * t + 33.0 / 7) + 1.0 / 7 * sin(26 * t + 8.0 / 5) + 1.0 / 9 * sin(27 * t + 17.0 / 10) + 1.0 / 16 * sin(31 * t + 32.0 / 7) + 1.0 / 8 * sin(32 * t + 8.0 / 5) - 1229.0 / 15) * theta(35 * EIGEN_PI - t) * theta(t - 31 * EIGEN_PI) + (92.0 / 3 * sin(t + 11.0 / 7) + 10.0 / 11 * sin(2 * t + 14.0 / 9) + 89.0 / 44 * sin(3 * t + 11.0 / 7) + 1.0 / 15 * sin(4 * t + 13.0 / 8) + 220.0 / 7) * theta(31 * EIGEN_PI - t) * theta(t - 27 * EIGEN_PI) + (-89.0 / 10 * sin(11.0 / 7 - 2 * t) + 73.0 / 5 * sin(t + 11.0 / 7) + 2.0 / 3 * sin(3 * t + 11.0 / 7) + 11.0 / 10 * sin(4 * t + 33.0 / 7) - 189.0 / 4) * theta(27 * EIGEN_PI - t) * theta(t - 23 * EIGEN_PI) + (-1.0 / 27 * sin(4.0 / 3 - 26 * t) - 1.0 / 16 * sin(11.0 / 9 - 17 * t) - 2.0 / 11 * sin(7.0 / 5 - 11 * t) - 1.0 / 8 * sin(13.0 / 10 - 10 * t) - 5.0 / 6 * sin(23.0 / 15 - 5 * t) + 181.0 / 9 * sin(t + 11.0 / 7) + 8.0 / 3 * sin(2 * t + 3.0 / 2) + 64.0 / 11 * sin(3 * t + 17.0 / 11) + 1.0 / 2 * sin(4 * t + 4.0 / 3) + 1.0 / 4 * sin(6 * t + 8.0 / 5) + 6.0 / 11 * sin(7 * t + 19.0 / 12) + 1.0 / 12 * sin(8 * t + 10.0 / 7) + 1.0 / 2 * sin(9 * t + 32.0 / 21) + 1.0 / 5 * sin(12 * t + 22.0 / 15) + 1.0 / 6 * sin(13 * t + 14.0 / 9) + 1.0 / 30 * sin(14 * t + 59.0 / 13) + 1.0 / 29 * sin(15 * t + 13.0 / 8) + 1.0 / 21 * sin(16 * t + 4.0 / 3) + 1.0 / 11 * sin(18 * t + 4.0 / 3) + 1.0 / 9 * sin(19 * t + 16.0 / 11) + 1.0 / 17 * sin(20 * t + 47.0 / 10) + 1.0 / 28 * sin(22 * t + 11.0 / 8) + 1.0 / 14 * sin(23 * t + 9.0 / 7) + 1.0 / 22 * sin(24 * t + 14.0 / 13) + 1.0 / 29 * sin(25 * t + 15.0 / 13) + 1.0 / 39 * sin(27 * t + 7.0 / 5) - 1343.0 / 12) * theta(23 * EIGEN_PI - t) * theta(t - 19 * EIGEN_PI) + (-1.0 / 11 * sin(31.0 / 21 - 16 * t) - 31.0 / 12 * sin(29.0 / 19 - 5 * t) + 514.0 / 21 * sin(t + 47.0 / 10) + 99.0 / 7 * sin(2 * t + 47.0 / 10) + 87.0 / 8 * sin(3 * t + 14.0 / 9) + 61.0 / 9 * sin(4 * t + 26.0 / 17) + 48.0 / 19 * sin(6 * t + 21.0 / 13) + 35.0 / 17 * sin(7 * t + 14.0 / 3) + 3.0 / 5 * sin(8 * t + 23.0 / 5) + 69.0 / 35 * sin(9 * t + 79.0 / 17) + 1.0 / 3 * sin(10 * t + 117.0 / 29) + 17.0 / 8 * sin(11 * t + 51.0 / 11) + 3.0 / 8 * sin(12 * t + 12.0 / 7) + 5.0 / 8 * sin(13 * t + 14.0 / 3) + 4.0 / 11 * sin(14 * t + 32.0 / 7) + 1.0 / 7 * sin(15 * t + 49.0 / 25) + 1.0 / 3 * sin(17 * t + 14.0 / 3) + 1.0 / 16 * sin(18 * t + 36.0 / 11) + 9.0 / 17 * sin(19 * t + 32.0 / 7) + 2.0 / 9 * sin(20 * t + 26.0 / 15) + 1.0 / 2 * sin(21 * t + 47.0 / 10) + 1.0 / 11 * sin(22 * t + 13.0 / 6) + 1.0 / 7 * sin(23 * t + 61.0 / 14) + 1.0 / 14 * sin(24 * t + 9.0 / 2) + 1.0 / 23 * sin(25 * t + 47.0 / 11) + 1.0 / 6 * sin(26 * t + 53.0 / 12) + 1.0 / 4 * sin(27 * t + 35.0 / 8) - 1109.0 / 11) * theta(19 * EIGEN_PI - t) * theta(t - 15 * EIGEN_PI) + (-1.0 / 18 * sin(23.0 / 17 - 79 * t) - 1.0 / 8 * sin(17.0 / 12 - 78 * t) - 1.0 / 14 * sin(7.0 / 5 - 77 * t) - 1.0 / 11 * sin(10.0 / 7 - 73 * t) - 1.0 / 20 * sin(18.0 / 13 - 72 * t) - 1.0 / 14 * sin(7.0 / 5 - 65 * t) - 1.0 / 16 * sin(7.0 / 6 - 64 * t) - 2.0 / 13 * sin(11.0 / 8 - 63 * t) - 1.0 / 7 * sin(11.0 / 8 - 62 * t) - 1.0 / 11 * sin(3.0 / 2 - 57 * t) - 1.0 / 7 * sin(18.0 / 13 - 56 * t) - 1.0 / 13 * sin(31.0 / 21 - 55 * t) - 3.0 / 10 * sin(38.0 / 25 - 49 * t) - 1.0 / 3 * sin(3.0 / 2 - 45 * t) - 2.0 / 7 * sin(3.0 / 2 - 40 * t) - 3.0 / 13 * sin(26.0 / 17 - 27 * t) - 7.0 / 15 * sin(19.0 / 13 - 26 * t) - 6.0 / 7 * sin(16.0 / 11 - 25 * t) - 19.0 / 14 * sin(19.0 / 13 - 24 * t) - 17.0 / 11 * sin(3.0 / 2 - 23 * t) - 3.0 / 10 * sin(16.0 / 11 - 22 * t) - 18.0 / 17 * sin(23.0 / 15 - 17 * t) - 25.0 / 6 * sin(17.0 / 11 - 16 * t) - 82.0 / 33 * sin(14.0 / 9 - 13 * t) - 55.0 / 27 * sin(14.0 / 9 - 11 * t) - 22.0 / 9 * sin(14.0 / 9 - 4 * t) - 7.0 / 4 * sin(11.0 / 7 - 2 * t) + 32.0 / 31 * sin(t + 11.0 / 7) + 165.0 / 41 * sin(3 * t + 11.0 / 7) + 111.0 / 28 * sin(5 * t + 11.0 / 7) + 13.0 / 11 * sin(6 * t + 33.0 / 7) + 31.0 / 11 * sin(7 * t + 19.0 / 12) + 1.0 / 12 * sin(8 * t + 55.0 / 12) + 17.0 / 9 * sin(9 * t + 11.0 / 7) + 95.0 / 32 * sin(10 * t + 19.0 / 12) + 17.0 / 6 * sin(12 * t + 11.0 / 7) + 53.0 / 12 * sin(14 * t + 19.0 / 12) + 47.0 / 16 * sin(15 * t + 11.0 / 7) + 51.0 / 13 * sin(18 * t + 8.0 / 5) + 28.0 / 13 * sin(19 * t + 18.0 / 11) + 2 * sin(20 * t + 18.0 / 11) + 7.0 / 9 * sin(21 * t + 18.0 / 11) + 1.0 / 9 * sin(28 * t + 19.0 / 11) + 1.0 / 13 * sin(29 * t + 23.0 / 15) + 1.0 / 50 * sin(30 * t + 133.0 / 44) + 2.0 / 11 * sin(31 * t + 23.0 / 13) + 1.0 / 5 * sin(32 * t + 23.0 / 14) + 1.0 / 9 * sin(33 * t + 37.0 / 8) + 10.0 / 19 * sin(34 * t + 13.0 / 8) + 1.0 / 20 * sin(35 * t + 35.0 / 8) + 3.0 / 8 * sin(36 * t + 8.0 / 5) + 1.0 / 11 * sin(37 * t + 17.0 / 11) + 1.0 / 8 * sin(38 * t + 23.0 / 14) + 1.0 / 5 * sin(39 * t + 23.0 / 14) + 1.0 / 12 * sin(41 * t + 23.0 / 15) + 1.0 / 13 * sin(42 * t + 10.0 / 7) + 1.0 / 21 * sin(43 * t + 33.0 / 7) + 1.0 / 51 * sin(44 * t + 1.0 / 3) + 1.0 / 12 * sin(46 * t + 51.0 / 11) + 1.0 / 2 * sin(47 * t + 23.0 / 14) + 1.0 / 18 * sin(48 * t + 13.0 / 8) + 1.0 / 35 * sin(50 * t + 10.0 / 7) + 1.0 / 6 * sin(51 * t + 5.0 / 3) + 1.0 / 24 * sin(52 * t + 37.0 / 8) + 1.0 / 9 * sin(53 * t + 19.0 / 12) + 1.0 / 37 * sin(54 * t + 11.0 / 8) + 1.0 / 5 * sin(58 * t + 12.0 / 7) + 1.0 / 27 * sin(59 * t + 29.0 / 13) + 1.0 / 9 * sin(60 * t + 12.0 / 7) + 1.0 / 8 * sin(66 * t + 5.0 / 3) + 1.0 / 16 * sin(67 * t + 17.0 / 9) + 2.0 / 11 * sin(68 * t + 7.0 / 4) + 1.0 / 28 * sin(69 * t + 23.0 / 11) + 1.0 / 17 * sin(70 * t + 7.0 / 4) + 1.0 / 10 * sin(71 * t + 28.0 / 17) + 1.0 / 28 * sin(74 * t + 12.0 / 7) + 1.0 / 30 * sin(75 * t + 16.0 / 9) + 1.0 / 14 * sin(76 * t + 23.0 / 14) + 1.0 / 9 * sin(80 * t + 13.0 / 8) + 593.0 / 11) * theta(15 * EIGEN_PI - t) * theta(t - 11 * EIGEN_PI) + (-1.0 / 67 * sin(4.0 / 9 - 79 * t) - 1.0 / 8 * sin(11.0 / 8 - 78 * t) - 1.0 / 12 * sin(4.0 / 3 - 71 * t) - 1.0 / 9 * sin(16.0 / 11 - 65 * t) - 1.0 / 16 * sin(8.0 / 7 - 64 * t) - 1.0 / 13 * sin(16.0 / 11 - 63 * t) - 1.0 / 7 * sin(34.0 / 23 - 61 * t) - 2.0 / 13 * sin(3.0 / 2 - 59 * t) - 1.0 / 20 * sin(10.0 / 9 - 57 * t) - 2.0 / 9 * sin(16.0 / 11 - 56 * t) - 2.0 / 5 * sin(10.0 / 7 - 54 * t) - 1.0 / 7 * sin(15.0 / 11 - 53 * t) - 1.0 / 6 * sin(14.0 / 9 - 51 * t) - 3.0 / 10 * sin(7.0 / 5 - 49 * t) - 1.0 / 14 * sin(16.0 / 13 - 48 * t) - 2.0 / 7 * sin(10.0 / 7 - 45 * t) - 1.0 / 26 * sin(14.0 / 13 - 42 * t) - 1.0 / 8 * sin(25.0 / 17 - 41 * t) - 5.0 / 13 * sin(3.0 / 2 - 35 * t) - 3.0 / 10 * sin(11.0 / 7 - 33 * t) - 5.0 / 9 * sin(26.0 / 17 - 31 * t) - 3.0 / 4 * sin(37.0 / 25 - 29 * t) - 1.0 / 13 * sin(9.0 / 10 - 28 * t) - 6.0 / 7 * sin(35.0 / 23 - 27 * t) - 1.0 / 16 * sin(13.0 / 10 - 26 * t) - 9.0 / 11 * sin(26.0 / 17 - 25 * t) - 3.0 / 4 * sin(17.0 / 11 - 23 * t) - 35.0 / 6 * sin(29.0 / 19 - 15 * t) - 18.0 / 11 * sin(3.0 / 2 - 14 * t) + 5.0 / 3 * sin(t + 11.0 / 7) + 4.0 / 5 * sin(2 * t + 8.0 / 5) + 19.0 / 10 * sin(3 * t + 8.0 / 5) + 8.0 / 9 * sin(4 * t + 19.0 / 12) + 13.0 / 25 * sin(5 * t + 11.0 / 7) + 8.0 / 17 * sin(6 * t + 8.0 / 5) + 4.0 / 11 * sin(7 * t + 21.0 / 13) + 3.0 / 11 * sin(8 * t + 21.0 / 13) + 9.0 / 8 * sin(9 * t + 13.0 / 8) + 21.0 / 8 * sin(10 * t + 8.0 / 5) + 9.0 / 10 * sin(11 * t + 14.0 / 9) + 3.0 / 8 * sin(12 * t + 23.0 / 14) + 18.0 / 13 * sin(13 * t + 5.0 / 3) + 1.0 / 6 * sin(16 * t + 15.0 / 8) + 44.0 / 7 * sin(17 * t + 13.0 / 8) + 46.0 / 47 * sin(18 * t + 61.0 / 13) + 37.0 / 15 * sin(19 * t + 19.0 / 12) + 3.0 / 13 * sin(20 * t + 65.0 / 14) + 2.0 / 5 * sin(21 * t + 7.0 / 4) + 17.0 / 13 * sin(22 * t + 13.0 / 8) + 3.0 / 8 * sin(24 * t + 14.0 / 9) + 1.0 / 21 * sin(30 * t + 1.0 / 5) + 5.0 / 16 * sin(32 * t + 8.0 / 5) + 1.0 / 5 * sin(34 * t + 3.0 / 2) + 1.0 / 5 * sin(36 * t + 8.0 / 5) + 1.0 / 12 * sin(37 * t + 14.0 / 3) + 2.0 / 9 * sin(38 * t + 18.0 / 11) + 1.0 / 10 * sin(39 * t + 25.0 / 13) + 4.0 / 11 * sin(40 * t + 12.0 / 7) + 1.0 / 12 * sin(43 * t + 23.0 / 11) + 1.0 / 43 * sin(44 * t + 15.0 / 11) + 10.0 / 19 * sin(46 * t + 17.0 / 10) + 3.0 / 7 * sin(47 * t + 16.0 / 9) + 1.0 / 35 * sin(50 * t + 9.0 / 7) + 1.0 / 13 * sin(52 * t + 13.0 / 8) + 1.0 / 10 * sin(55 * t + 19.0 / 12) + 1.0 / 24 * sin(58 * t + 6.0 / 5) + 2.0 / 13 * sin(60 * t + 5.0 / 3) + 1.0 / 9 * sin(62 * t + 8.0 / 5) + 1.0 / 21 * sin(66 * t + 7.0 / 4) + 1.0 / 86 * sin(67 * t + 61.0 / 14) + 1.0 / 40 * sin(68 * t + 16.0 / 13) + 1.0 / 47 * sin(69 * t + 9.0 / 2) + 1.0 / 22 * sin(70 * t + 9.0 / 5) + 2.0 / 13 * sin(73 * t + 11.0 / 6) + 1.0 / 23 * sin(74 * t + 23.0 / 12) + 1.0 / 12 * sin(75 * t + 5.0 / 3) + 1.0 / 7 * sin(76 * t + 15.0 / 8) + 1.0 / 7 * sin(77 * t + 24.0 / 13) + 1.0 / 67 * sin(80 * t + 12.0 / 5) - 1097.0 / 13) * theta(11 * EIGEN_PI - t) * theta(t - 7 * EIGEN_PI) + (-2.0 / 11 * sin(1.0 / 5 - 5 * t) - 56.0 / 3 * sin(23.0 / 15 - t) + 8.0 / 13 * sin(2 * t + 69.0 / 34) + 2.0 / 9 * sin(3 * t + 15.0 / 4) + 5.0 / 11 * sin(4 * t + 25.0 / 13) - 268.0 / 3) * theta(7 * EIGEN_PI - t) * theta(t - 3 * EIGEN_PI) + (467.0 / 17 * sin(t + 11.0 / 7) + 9.0 / 14 * sin(2 * t + 31.0 / 7) + 11.0 / 7 * sin(3 * t + 37.0 / 19) + 1.0 / 4 * sin(4 * t + 37.0 / 10) + 355.0 / 8) * theta(3 * EIGEN_PI - t) * theta(t + EIGEN_PI)) * theta(sqrt(sgn(sin(t / 2))));
        return x_t+550.0;
    }
    float doge_custom_y(float t) {
        float y_t = ((281.0 / 9 * sin(t + 33.0 / 7) + 23.0 / 7 * sin(2 * t + 11.0 / 7) + 3.0 / 5 * sin(3 * t + 11.0 / 7) + 8.0 / 15 * sin(4 * t + 11.0 / 7) - 217.0 / 3) * theta(99 * EIGEN_PI - t) * theta(t - 95 * EIGEN_PI) + (-3.0 / 5 * sin(14.0 / 9 - 7 * t) - 6.0 / 7 * sin(14.0 / 9 - 5 * t) - 11.0 / 14 * sin(14.0 / 9 - 3 * t) + 310.0 / 23 * sin(t + 11.0 / 7) + 113.0 / 10 * sin(2 * t + 11.0 / 7) + 62.0 / 13 * sin(4 * t + 11.0 / 7) + 2 * sin(6 * t + 11.0 / 7) + 15.0 / 14 * sin(8 * t + 11.0 / 7) + 1.0 / 5 * sin(9 * t + 11.0 / 7) + 2.0 / 3 * sin(10 * t + 11.0 / 7) - 1261.0 / 8) * theta(95 * EIGEN_PI - t) * theta(t - 91 * EIGEN_PI) + (145.0 / 11 * sin(t + 33.0 / 7) + 62.0 / 25 * sin(2 * t + 33.0 / 7) + 2.0 / 11 * sin(3 * t + 19.0 / 12) + 13.0 / 9 * sin(4 * t + 33.0 / 7) + 4.0 / 15 * sin(5 * t + 8.0 / 5) + 1918.0 / 9) * theta(91 * EIGEN_PI - t) * theta(t - 87 * EIGEN_PI) + (-5.0 / 8 * sin(11.0 / 7 - 5 * t) - 7.0 / 10 * sin(11.0 / 7 - 4 * t) - 12.0 / 5 * sin(11.0 / 7 - 3 * t) - 6.0 / 7 * sin(14.0 / 9 - 2 * t) - 729.0 / 28 * sin(11.0 / 7 - t) + 2133.0 / 13) * theta(87 * EIGEN_PI - t) * theta(t - 83 * EIGEN_PI) + (-2.0 / 13 * sin(17.0 / 11 - 17 * t) - 1.0 / 12 * sin(13.0 / 9 - 14 * t) - 7.0 / 13 * sin(20.0 / 13 - 13 * t) - 1.0 / 5 * sin(11.0 / 7 - 9 * t) - 1.0 / 2 * sin(14.0 / 9 - 8 * t) - 4.0 / 11 * sin(11.0 / 7 - 7 * t) - 13.0 / 19 * sin(14.0 / 9 - 6 * t) - 3.0 / 11 * sin(11.0 / 7 - 2 * t) - 19.0 / 4 * sin(11.0 / 7 - t) + 1.0 / 10 * sin(3 * t + 65.0 / 14) + 1.0 / 25 * sin(4 * t + 7.0 / 4) + 1.0 / 29 * sin(5 * t + 51.0 / 11) + 7.0 / 9 * sin(10 * t + 8.0 / 5) + 21.0 / 16 * sin(11 * t + 8.0 / 5) + 23.0 / 14 * sin(12 * t + 8.0 / 5) + 3.0 / 10 * sin(15 * t + 23.0 / 14) + 2.0 / 13 * sin(16 * t + 11.0 / 7) + 1.0 / 14 * sin(19 * t + 75.0 / 16) + 2.0 / 9 * sin(20 * t + 8.0 / 5) + 1.0 / 11 * sin(21 * t + 18.0 / 11) + 1.0 / 6 * sin(22 * t + 8.0 / 5) - 503.0 / 11) * theta(83 * EIGEN_PI - t) * theta(t - 79 * EIGEN_PI) + (-7.0 / 11 * sin(16.0 / 11 - 22 * t) - 2.0 / 5 * sin(26.0 / 17 - 17 * t) - 1.0 / 62 * sin(10.0 / 11 - 10 * t) - 1.0 / 22 * sin(13.0 / 9 - 9 * t) - 2.0 / 11 * sin(14.0 / 9 - 8 * t) - 1.0 / 9 * sin(23.0 / 15 - 7 * t) - 1.0 / 3 * sin(14.0 / 9 - 6 * t) - 48.0 / 7 * sin(11.0 / 7 - t) + 5.0 / 8 * sin(2 * t + 11.0 / 7) + 1.0 / 44 * sin(3 * t + 9.0 / 2) + 1.0 / 44 * sin(4 * t + 19.0 / 12) + 1.0 / 13 * sin(5 * t + 11.0 / 7) + 1.0 / 13 * sin(11 * t + 16.0 / 9) + 5.0 / 7 * sin(12 * t + 13.0 / 8) + 1.0 / 25 * sin(13 * t + 86.0 / 19) + 1.0 / 8 * sin(14 * t + 3.0 / 2) + 1.0 / 4 * sin(15 * t + 33.0 / 7) + 2.0 / 7 * sin(16 * t + 19.0 / 12) + 1.0 / 55 * sin(18 * t + 1.0 / 97) + 1.0 / 15 * sin(19 * t + 15.0 / 8) + 12.0 / 23 * sin(20 * t + 5.0 / 3) + 1.0 / 61 * sin(21 * t + 15.0 / 11) - 1091.0 / 21) * theta(79 * EIGEN_PI - t) * theta(t - 75 * EIGEN_PI) + (-3.0 / 11 * sin(14.0 / 9 - 45 * t) - 1.0 / 27 * sin(11.0 / 7 - 44 * t) - 1.0 / 8 * sin(20.0 / 13 - 42 * t) - 5.0 / 13 * sin(17.0 / 11 - 41 * t) - 1.0 / 4 * sin(14.0 / 9 - 37 * t) - 3.0 / 7 * sin(26.0 / 17 - 34 * t) - 3.0 / 13 * sin(13.0 / 9 - 30 * t) - 1.0 / 5 * sin(14.0 / 9 - 29 * t) - 13.0 / 14 * sin(32.0 / 21 - 27 * t) - 5.0 / 8 * sin(34.0 / 23 - 26 * t) - 21.0 / 22 * sin(14.0 / 9 - 20 * t) - 9.0 / 5 * sin(14.0 / 9 - 19 * t) - 3.0 / 11 * sin(17.0 / 11 - 18 * t) - 5.0 / 6 * sin(23.0 / 15 - 17 * t) - 113.0 / 6 * sin(11.0 / 7 - 5 * t) - 256.0 / 11 * sin(14.0 / 9 - 4 * t) - 141.0 / 2 * sin(11.0 / 7 - 3 * t) + 367.0 / 8 * sin(t + 33.0 / 7) + 237.0 / 5 * sin(2 * t + 11.0 / 7) + 3.0 / 2 * sin(6 * t + 19.0 / 12) + 5.0 / 12 * sin(7 * t + 55.0 / 12) + 25.0 / 6 * sin(8 * t + 11.0 / 7) + 8.0 / 5 * sin(9 * t + 47.0 / 10) + 13.0 / 11 * sin(10 * t + 47.0 / 10) + 46.0 / 9 * sin(11 * t + 33.0 / 7) + 13.0 / 6 * sin(12 * t + 33.0 / 7) + 9.0 / 4 * sin(13 * t + 33.0 / 7) + 1.0 / 2 * sin(14 * t + 11.0 / 7) + 1.0 / 15 * sin(15 * t + 13.0 / 8) + 9.0 / 14 * sin(16 * t + 14.0 / 9) + 11.0 / 23 * sin(21 * t + 47.0 / 10) + 1.0 / 2 * sin(22 * t + 19.0 / 12) + 3.0 / 10 * sin(23 * t + 79.0 / 17) + 3.0 / 5 * sin(24 * t + 8.0 / 5) + 2.0 / 5 * sin(25 * t + 61.0 / 13) + 1.0 / 5 * sin(28 * t + 18.0 / 11) + 2.0 / 9 * sin(31 * t + 47.0 / 10) + 1.0 / 2 * sin(32 * t + 5.0 / 3) + 4.0 / 11 * sin(33 * t + 33.0 / 7) + 6.0 / 13 * sin(35 * t + 33.0 / 7) + 1.0 / 12 * sin(36 * t + 19.0 / 11) + 1.0 / 8 * sin(38 * t + 19.0 / 13) + 1.0 / 30 * sin(39 * t + 12.0 / 7) + 1.0 / 11 * sin(40 * t + 11.0 / 7) + 1.0 / 6 * sin(43 * t + 37.0 / 8) + 1.0 / 6 * sin(46 * t + 5.0 / 3) - 1317.0 / 8) * theta(75 * EIGEN_PI - t) * theta(t - 71 * EIGEN_PI) + (-1.0 / 11 * sin(5.0 / 4 - 37 * t) - 6.0 / 17 * sin(19.0 / 13 - 36 * t) - 10.0 / 19 * sin(13.0 / 9 - 32 * t) - 1.0 / 7 * sin(3.0 / 2 - 26 * t) - 3.0 / 11 * sin(10.0 / 7 - 23 * t) - 4.0 / 7 * sin(22.0 / 15 - 22 * t) - 1.0 / 3 * sin(31.0 / 21 - 19 * t) - 5.0 / 9 * sin(3.0 / 2 - 18 * t) - 20.0 / 9 * sin(26.0 / 17 - 12 * t) - 652.0 / 19 * sin(11.0 / 7 - 2 * t) - 562.0 / 5 * sin(11.0 / 7 - t) + 295.0 / 17 * sin(3 * t + 19.0 / 12) + 67.0 / 11 * sin(4 * t + 19.0 / 12) + 51.0 / 14 * sin(5 * t + 8.0 / 5) + 63.0 / 5 * sin(6 * t + 8.0 / 5) + 37.0 / 7 * sin(7 * t + 8.0 / 5) + 28.0 / 11 * sin(8 * t + 21.0 / 13) + 1.0 / 26 * sin(9 * t + 38.0 / 9) + 7.0 / 6 * sin(10 * t + 13.0 / 8) + 91.0 / 45 * sin(11 * t + 8.0 / 5) + 11.0 / 16 * sin(13 * t + 13.0 / 8) + 1.0 / 46 * sin(14 * t + 137.0 / 46) + 3.0 / 7 * sin(15 * t + 13.0 / 8) + 2.0 / 5 * sin(16 * t + 28.0 / 17) + 1.0 / 6 * sin(17 * t + 14.0 / 9) + 4.0 / 11 * sin(20 * t + 17.0 / 10) + 13.0 / 25 * sin(21 * t + 13.0 / 8) + 3.0 / 10 * sin(24 * t + 7.0 / 4) + 2.0 / 5 * sin(25 * t + 23.0 / 14) + 1.0 / 83 * sin(27 * t + 7.0 / 10) + 1.0 / 9 * sin(28 * t + 51.0 / 11) + 1.0 / 4 * sin(29 * t + 5.0 / 3) + 2.0 / 9 * sin(30 * t + 7.0 / 4) + 2.0 / 9 * sin(31 * t + 21.0 / 13) + 1.0 / 30 * sin(33 * t + 13.0 / 10) + 1.0 / 7 * sin(34 * t + 13.0 / 7) + 4.0 / 11 * sin(35 * t + 17.0 / 10) + 1.0 / 21 * sin(38 * t + 45.0 / 23) - 661.0 / 7) * theta(71 * EIGEN_PI - t) * theta(t - 67 * EIGEN_PI) + (-1.0 / 17 * sin(26.0 / 17 - 9 * t) - 31.0 / 6 * sin(11.0 / 7 - 2 * t) + 87.0 / 7 * sin(t + 11.0 / 7) + 106.0 / 11 * sin(3 * t + 11.0 / 7) + 37.0 / 11 * sin(4 * t + 11.0 / 7) + 88.0 / 29 * sin(5 * t + 11.0 / 7) + 3.0 / 11 * sin(6 * t + 61.0 / 13) + 4.0 / 11 * sin(7 * t + 11.0 / 7) + 1.0 / 4 * sin(8 * t + 47.0 / 10) + 4.0 / 9 * sin(10 * t + 33.0 / 7) + 5.0 / 13 * sin(11 * t + 11.0 / 7) + 3.0 / 10 * sin(12 * t + 8.0 / 5) + 7.0 / 12 * sin(13 * t + 19.0 / 12) + 1492.0 / 13) * theta(67 * EIGEN_PI - t) * theta(t - 63 * EIGEN_PI) + (-1.0 / 7 * sin(23.0 / 15 - 28 * t) - 1.0 / 6 * sin(14.0 / 9 - 25 * t) - 1.0 / 3 * sin(17.0 / 11 - 23 * t) - 5.0 / 8 * sin(17.0 / 11 - 20 * t) - 2.0 / 13 * sin(3.0 / 2 - 18 * t) - 8.0 / 11 * sin(17.0 / 11 - 15 * t) - 16.0 / 9 * sin(14.0 / 9 - 13 * t) - 69.0 / 70 * sin(17.0 / 11 - 8 * t) - 127.0 / 23 * sin(11.0 / 7 - 7 * t) - 23.0 / 10 * sin(11.0 / 7 - 5 * t) - 94.0 / 9 * sin(11.0 / 7 - 2 * t) - 231.0 / 10 * sin(11.0 / 7 - t) + 325.0 / 11 * sin(3 * t + 11.0 / 7) + 15.0 / 16 * sin(4 * t + 14.0 / 9) + 1.0 / 10 * sin(6 * t + 11.0 / 8) + 2.0 / 11 * sin(9 * t + 37.0 / 8) + 15.0 / 8 * sin(10 * t + 19.0 / 12) + 1.0 / 11 * sin(11 * t + 10.0 / 7) + 17.0 / 11 * sin(12 * t + 8.0 / 5) + 3.0 / 14 * sin(14 * t + 65.0 / 14) + 4.0 / 7 * sin(16 * t + 33.0 / 7) + 11.0 / 9 * sin(17 * t + 47.0 / 10) + 6.0 / 7 * sin(19 * t + 47.0 / 10) + 3.0 / 5 * sin(21 * t + 61.0 / 13) + 5.0 / 11 * sin(22 * t + 33.0 / 7) + 1.0 / 8 * sin(24 * t + 22.0 / 13) + 1.0 / 37 * sin(26 * t + 5.0 / 3) + 1.0 / 8 * sin(27 * t + 14.0 / 9) + 1033.0 / 8) * theta(63 * EIGEN_PI - t) * theta(t - 59 * EIGEN_PI) + (-4.0 / 9 * sin(37.0 / 25 - 19 * t) - 1.0 / 10 * sin(14.0 / 15 - 18 * t) - 2.0 / 3 * sin(28.0 / 19 - 17 * t) - 1.0 / 8 * sin(19.0 / 18 - 16 * t) - 5.0 / 6 * sin(19.0 / 13 - 15 * t) - 1.0 / 5 * sin(9.0 / 8 - 14 * t) - 6.0 / 7 * sin(35.0 / 23 - 13 * t) - 26.0 / 17 * sin(3.0 / 2 - 11 * t) - 26.0 / 11 * sin(26.0 / 17 - 9 * t) - 3.0 / 13 * sin(11.0 / 16 - 8 * t) - 13.0 / 4 * sin(20.0 / 13 - 7 * t) - 2.0 / 11 * sin(5.0 / 7 - 6 * t) - 51.0 / 8 * sin(20.0 / 13 - 5 * t) - 35.0 / 2 * sin(14.0 / 9 - 3 * t) - 7.0 / 12 * sin(1.0 / 2 - 2 * t) - 1444.0 / 9 * sin(11.0 / 7 - t) + 7.0 / 11 * sin(4 * t + 11.0 / 8) + 3.0 / 11 * sin(10 * t + 5.0 / 4) + 2.0 / 9 * sin(12 * t + 6.0 / 5) + 1.0 / 20 * sin(20 * t + 5.0 / 4) - 633.0 / 7) * theta(59 * EIGEN_PI - t) * theta(t - 55 * EIGEN_PI) + (-1.0 / 47 * sin(1.0 / 7 - 42 * t) - 1.0 / 8 * sin(11.0 / 8 - 23 * t) + 719.0 / 14 * sin(t + 33.0 / 7) + 588.0 / 13 * sin(2 * t + 33.0 / 7) + 79.0 / 8 * sin(3 * t + 11.0 / 7) + 193.0 / 16 * sin(4 * t + 11.0 / 7) + 146.0 / 13 * sin(5 * t + 47.0 / 10) + 63.0 / 11 * sin(6 * t + 47.0 / 10) + 19.0 / 6 * sin(7 * t + 65.0 / 14) + 83.0 / 14 * sin(8 * t + 14.0 / 3) + 14.0 / 3 * sin(9 * t + 61.0 / 13) + 15.0 / 8 * sin(10 * t + 14.0 / 3) + 1.0 / 10 * sin(11 * t + 77.0 / 19) + 2.0 / 9 * sin(12 * t + 11.0 / 7) + 8.0 / 11 * sin(13 * t + 19.0 / 13) + 49.0 / 25 * sin(14 * t + 26.0 / 17) + 2.0 / 9 * sin(15 * t + 19.0 / 13) + 1.0 / 8 * sin(16 * t + 40.0 / 9) + 2.0 / 3 * sin(17 * t + 23.0 / 5) + 7.0 / 8 * sin(18 * t + 37.0 / 8) + 10.0 / 13 * sin(19 * t + 14.0 / 3) + 1.0 / 2 * sin(20 * t + 51.0 / 11) + 1.0 / 12 * sin(21 * t + 11.0 / 6) + 3.0 / 8 * sin(22 * t + 26.0 / 17) + 1.0 / 6 * sin(24 * t + 20.0 / 13) + 1.0 / 5 * sin(25 * t + 103.0 / 23) + 1.0 / 3 * sin(26 * t + 41.0 / 9) + 3.0 / 10 * sin(27 * t + 37.0 / 8) + 2.0 / 9 * sin(28 * t + 60.0 / 13) + 1.0 / 9 * sin(29 * t + 3.0 / 2) + 1.0 / 9 * sin(30 * t + 13.0 / 9) + 3.0 / 13 * sin(31 * t + 10.0 / 7) + 3.0 / 7 * sin(32 * t + 10.0 / 7) + 1.0 / 9 * sin(33 * t + 4.0 / 3) + 1.0 / 9 * sin(34 * t + 23.0 / 5) + 1.0 / 6 * sin(35 * t + 9.0 / 2) + 2.0 / 7 * sin(36 * t + 32.0 / 7) + 1.0 / 6 * sin(37 * t + 41.0 / 9) + 1.0 / 6 * sin(38 * t + 14.0 / 3) + 1.0 / 37 * sin(39 * t + 11.0 / 7) + 1.0 / 9 * sin(40 * t + 3.0 / 2) + 1.0 / 7 * sin(41 * t + 13.0 / 9) + 1.0 / 15 * sin(43 * t + 3.0 / 2) + 1720.0 / 13) * theta(55 * EIGEN_PI - t) * theta(t - 51 * EIGEN_PI) + (-44.0 / 5 * sin(11.0 / 7 - t) + 24.0 / 5 * sin(2 * t + 11.0 / 7) + 2.0 / 9 * sin(3 * t + 17.0 / 11) + 2507.0 / 16) * theta(51 * EIGEN_PI - t) * theta(t - 47 * EIGEN_PI) + (-1.0 / 8 * sin(32.0 / 21 - 24 * t) - 1.0 / 3 * sin(4.0 / 3 - 16 * t) + 527.0 / 6 * sin(t + 33.0 / 7) + 112.0 / 5 * sin(2 * t + 33.0 / 7) + 147.0 / 13 * sin(3 * t + 11.0 / 7) + 89.0 / 8 * sin(4 * t + 33.0 / 7) + 81.0 / 4 * sin(5 * t + 14.0 / 9) + 100.0 / 9 * sin(6 * t + 47.0 / 10) + 13.0 / 7 * sin(7 * t + 12.0 / 7) + 23.0 / 4 * sin(8 * t + 14.0 / 3) + 164.0 / 17 * sin(9 * t + 51.0 / 11) + 79.0 / 16 * sin(10 * t + 37.0 / 8) + 13.0 / 4 * sin(11 * t + 23.0 / 5) + 17.0 / 7 * sin(12 * t + 23.0 / 5) + 9.0 / 13 * sin(13 * t + 104.0 / 23) + 25.0 / 26 * sin(14 * t + 61.0 / 13) + 5.0 / 2 * sin(15 * t + 35.0 / 23) + 6.0 / 7 * sin(17 * t + 34.0 / 23) + 1.0 / 5 * sin(18 * t + 9.0 / 7) + 4.0 / 11 * sin(19 * t + 50.0 / 11) + 5.0 / 16 * sin(20 * t + 9.0 / 2) + 5.0 / 13 * sin(21 * t + 86.0 / 19) + 3.0 / 7 * sin(22 * t + 50.0 / 11) + 1.0 / 4 * sin(23 * t + 9.0 / 2) + 8.0 / 11 * sin(25 * t + 28.0 / 19) + 3.0 / 11 * sin(26 * t + 75.0 / 16) + 1.0 / 9 * sin(27 * t + 17.0 / 4) + 4.0 / 9 * sin(28 * t + 9.0 / 2) + 4.0 / 9 * sin(29 * t + 31.0 / 7) + 6.0 / 13 * sin(30 * t + 22.0 / 5) + 5.0 / 13 * sin(31 * t + 22.0 / 5) + 10.0 / 19 * sin(32 * t + 9.0 / 2) + 817.0 / 7) * theta(47 * EIGEN_PI - t) * theta(t - 43 * EIGEN_PI) + (-1.0 / 31 * sin(13.0 / 11 - 8 * t) - 11.0 / 14 * sin(14.0 / 9 - 7 * t) - 19.0 / 20 * sin(11.0 / 7 - 5 * t) - 25.0 / 8 * sin(11.0 / 7 - 3 * t) - 71.0 / 3 * sin(11.0 / 7 - t) + 17.0 / 16 * sin(2 * t + 14.0 / 9) + 3.0 / 8 * sin(4 * t + 23.0 / 15) + 1.0 / 21 * sin(6 * t + 15.0 / 11) + 47.0 / 6) * theta(43 * EIGEN_PI - t) * theta(t - 39 * EIGEN_PI) + (-1.0 / 6 * sin(14.0 / 9 - 13 * t) - 3.0 / 8 * sin(11.0 / 7 - 11 * t) - 5.0 / 9 * sin(11.0 / 7 - 9 * t) - 2.0 / 9 * sin(17.0 / 11 - 7 * t) - 29.0 / 14 * sin(11.0 / 7 - 5 * t) - 22.0 / 9 * sin(11.0 / 7 - 3 * t) + 71.0 / 7 * sin(t + 33.0 / 7) + 241.0 / 16 * sin(2 * t + 11.0 / 7) + 31.0 / 9 * sin(4 * t + 11.0 / 7) + 9.0 / 8 * sin(6 * t + 11.0 / 7) + 5.0 / 9 * sin(8 * t + 11.0 / 7) + 1.0 / 2 * sin(10 * t + 11.0 / 7) + 1.0 / 8 * sin(12 * t + 19.0 / 12) + 4.0 / 13 * sin(14 * t + 11.0 / 7) - 2043.0 / 14) * theta(39 * EIGEN_PI - t) * theta(t - 35 * EIGEN_PI) + (-1.0 / 53 * sin(28.0 / 19 - 31 * t) - 1.0 / 19 * sin(13.0 / 9 - 29 * t) - 1.0 / 18 * sin(17.0 / 12 - 26 * t) - 1.0 / 8 * sin(17.0 / 11 - 25 * t) - 1.0 / 7 * sin(14.0 / 9 - 19 * t) - 3.0 / 8 * sin(3.0 / 2 - 18 * t) - 2.0 / 3 * sin(11.0 / 7 - 8 * t) - 16.0 / 9 * sin(14.0 / 9 - 7 * t) - 85.0 / 3 * sin(11.0 / 7 - t) + 17 * sin(2 * t + 11.0 / 7) + 31.0 / 4 * sin(3 * t + 33.0 / 7) + 60.0 / 7 * sin(4 * t + 11.0 / 7) + 25.0 / 8 * sin(5 * t + 33.0 / 7) + 68.0 / 9 * sin(6 * t + 19.0 / 12) + 13.0 / 12 * sin(9 * t + 19.0 / 12) + 1.0 / 39 * sin(10 * t + 22.0 / 7) + 1.0 / 3 * sin(11 * t + 14.0 / 9) + 13.0 / 14 * sin(12 * t + 8.0 / 5) + 1.0 / 57 * sin(13 * t + 5.0 / 3) + 10.0 / 11 * sin(14 * t + 11.0 / 7) + 1.0 / 19 * sin(15 * t + 40.0 / 9) + 2.0 / 5 * sin(16 * t + 11.0 / 7) + 1.0 / 16 * sin(17 * t + 13.0 / 7) + 1.0 / 33 * sin(20 * t + 4.0 / 3) + 3.0 / 13 * sin(22 * t + 11.0 / 7) + 1.0 / 27 * sin(23 * t + 59.0 / 13) + 1.0 / 3 * sin(24 * t + 8.0 / 5) + 1.0 / 8 * sin(28 * t + 5.0 / 3) + 1.0 / 5 * sin(30 * t + 23.0 / 14) + 1.0 / 6 * sin(32 * t + 8.0 / 5) + 1.0 / 60 * sin(33 * t + 31.0 / 16) + 1.0 / 8 * sin(34 * t + 11.0 / 7) - 1047.0 / 10) * theta(35 * EIGEN_PI - t) * theta(t - 31 * EIGEN_PI) + (64.0 / 15 * sin(t + 11.0 / 7) + 80.0 / 9 * sin(2 * t + 33.0 / 7) + 1.0 / 12 * sin(3 * t + 55.0 / 12) + 17.0 / 10 * sin(4 * t + 33.0 / 7) + 767.0 / 11) * theta(31 * EIGEN_PI - t) * theta(t - 27 * EIGEN_PI) + (-9.0 / 7 * sin(11.0 / 7 - 4 * t) - 48.0 / 5 * sin(11.0 / 7 - 2 * t) - 231.0 / 13 * sin(11.0 / 7 - t) + 7.0 / 8 * sin(3 * t + 11.0 / 7) + 1007.0 / 12) * theta(27 * EIGEN_PI - t) * theta(t - 23 * EIGEN_PI) + (-1.0 / 11 * sin(26.0 / 17 - 25 * t) - 1.0 / 25 * sin(16.0 / 11 - 22 * t) - 1.0 / 8 * sin(20.0 / 13 - 21 * t) - 1.0 / 31 * sin(3.0 / 4 - 17 * t) - 1.0 / 33 * sin(7.0 / 15 - 15 * t) - 1.0 / 14 * sin(17.0 / 14 - 13 * t) - 1.0 / 3 * sin(23.0 / 15 - 9 * t) - 7.0 / 8 * sin(14.0 / 9 - 6 * t) - 9.0 / 13 * sin(34.0 / 23 - 5 * t) - 13.0 / 9 * sin(26.0 / 17 - 3 * t) - 17.0 / 5 * sin(11.0 / 7 - t) + 17.0 / 7 * sin(2 * t + 14.0 / 9) + 71.0 / 13 * sin(4 * t + 14.0 / 9) + 8.0 / 13 * sin(7 * t + 34.0 / 23) + 19.0 / 13 * sin(8 * t + 23.0 / 15) + 2.0 / 9 * sin(10 * t + 47.0 / 10) + 1.0 / 22 * sin(11 * t + 14.0 / 13) + 3.0 / 7 * sin(12 * t + 3.0 / 2) + 1.0 / 5 * sin(14 * t + 13.0 / 9) + 1.0 / 5 * sin(16 * t + 13.0 / 9) + 1.0 / 14 * sin(18 * t + 17.0 / 13) + 1.0 / 14 * sin(19 * t + 9.0 / 7) + 2.0 / 11 * sin(20 * t + 19.0 / 13) + 1.0 / 9 * sin(23 * t + 17.0 / 12) + 1.0 / 8 * sin(24 * t + 13.0 / 9) + 1.0 / 73 * sin(26 * t + 4.0 / 3) + 1.0 / 67 * sin(27 * t + 54.0 / 53) - 649.0 / 9) * theta(23 * EIGEN_PI - t) * theta(t - 19 * EIGEN_PI) + (-1.0 / 29 * sin(36.0 / 37 - 19 * t) - 51.0 / 11 * sin(11.0 / 7 - 6 * t) + 61.0 / 7 * sin(t + 19.0 / 12) + 77.0 / 5 * sin(2 * t + 47.0 / 10) + 73.0 / 10 * sin(3 * t + 61.0 / 13) + 1.0 / 13 * sin(4 * t + 38.0 / 15) + 26.0 / 7 * sin(5 * t + 11.0 / 7) + 11.0 / 6 * sin(7 * t + 13.0 / 8) + 21.0 / 11 * sin(8 * t + 51.0 / 11) + 19.0 / 9 * sin(9 * t + 37.0 / 8) + 3.0 / 7 * sin(10 * t + 13.0 / 3) + 17.0 / 10 * sin(11 * t + 14.0 / 3) + 9.0 / 19 * sin(12 * t + 22.0 / 13) + 1.0 / 16 * sin(13 * t + 43.0 / 44) + 2.0 / 9 * sin(14 * t + 16.0 / 13) + 8.0 / 13 * sin(15 * t + 17.0 / 12) + 4.0 / 7 * sin(16 * t + 18.0 / 13) + 1.0 / 2 * sin(17 * t + 7.0 / 5) + 1.0 / 5 * sin(18 * t + 14.0 / 11) + 1.0 / 15 * sin(20 * t + 11.0 / 5) + 4.0 / 13 * sin(21 * t + 32.0 / 7) + 1.0 / 6 * sin(22 * t + 40.0 / 9) + 1.0 / 16 * sin(23 * t + 33.0 / 8) + 1.0 / 8 * sin(24 * t + 14.0 / 3) + 1.0 / 5 * sin(25 * t + 34.0 / 23) + 1.0 / 9 * sin(26 * t + 15.0 / 16) + 3.0 / 13 * sin(27 * t + 5.0 / 4) - 525.0 / 13) * theta(19 * EIGEN_PI - t) * theta(t - 15 * EIGEN_PI) + (-1.0 / 13 * sin(13.0 / 9 - 78 * t) - 1.0 / 21 * sin(3.0 / 2 - 77 * t) - 1.0 / 81 * sin(19.0 / 14 - 76 * t) - 1.0 / 7 * sin(16.0 / 11 - 73 * t) - 1.0 / 8 * sin(7.0 / 5 - 72 * t) - 1.0 / 38 * sin(13.0 / 10 - 71 * t) - 1.0 / 20 * sin(7.0 / 5 - 70 * t) - 1.0 / 10 * sin(20.0 / 13 - 69 * t) - 1.0 / 9 * sin(31.0 / 21 - 64 * t) - 1.0 / 56 * sin(4.0 / 3 - 63 * t) - 1.0 / 31 * sin(13.0 / 10 - 62 * t) - 1.0 / 25 * sin(7.0 / 5 - 60 * t) - 1.0 / 30 * sin(11.0 / 8 - 59 * t) - 1.0 / 21 * sin(14.0 / 9 - 57 * t) - 1.0 / 43 * sin(19.0 / 15 - 50 * t) - 3.0 / 14 * sin(26.0 / 17 - 49 * t) - 1.0 / 10 * sin(10.0 / 7 - 48 * t) - 1.0 / 6 * sin(13.0 / 9 - 46 * t) - 3.0 / 7 * sin(3.0 / 2 - 45 * t) - 1.0 / 9 * sin(4.0 / 3 - 44 * t) - 1.0 / 4 * sin(14.0 / 9 - 43 * t) - 1.0 / 13 * sin(17.0 / 11 - 38 * t) - 3.0 / 10 * sin(35.0 / 23 - 37 * t) - 2.0 / 9 * sin(20.0 / 13 - 35 * t) - 1.0 / 14 * sin(4.0 / 3 - 24 * t) - 5.0 / 7 * sin(23.0 / 15 - 23 * t) - 1.0 / 2 * sin(26.0 / 17 - 22 * t) - 13.0 / 25 * sin(26.0 / 17 - 21 * t) - 3.0 / 4 * sin(17.0 / 11 - 20 * t) - 1.0 / 2 * sin(17.0 / 11 - 19 * t) - 12.0 / 5 * sin(14.0 / 9 - 16 * t) - 17.0 / 7 * sin(11.0 / 7 - 13 * t) - 34.0 / 11 * sin(14.0 / 9 - 11 * t) - 12.0 / 7 * sin(14.0 / 9 - 9 * t) - 17.0 / 7 * sin(11.0 / 7 - 7 * t) - 18.0 / 7 * sin(11.0 / 7 - 5 * t) + 57.0 / 7 * sin(t + 11.0 / 7) + 43.0 / 10 * sin(2 * t + 11.0 / 7) + sin(3 * t + 33.0 / 7) + 16.0 / 7 * sin(4 * t + 11.0 / 7) + 17.0 / 13 * sin(6 * t + 11.0 / 7) + 9.0 / 7 * sin(8 * t + 11.0 / 7) + 14.0 / 9 * sin(10 * t + 19.0 / 12) + 19.0 / 9 * sin(12 * t + 19.0 / 12) + 8.0 / 5 * sin(14 * t + 8.0 / 5) + 1.0 / 12 * sin(15 * t + 21.0 / 13) + 1.0 / 15 * sin(17 * t + 10.0 / 7) + 1.0 / 65 * sin(18 * t + 29.0 / 7) + 1.0 / 3 * sin(25 * t + 33.0 / 7) + 1.0 / 5 * sin(27 * t + 17.0 / 10) + 1.0 / 6 * sin(28 * t + 23.0 / 13) + 4.0 / 11 * sin(29 * t + 18.0 / 11) + 2.0 / 11 * sin(30 * t + 27.0 / 16) + 5.0 / 14 * sin(31 * t + 33.0 / 7) + 3.0 / 10 * sin(32 * t + 8.0 / 5) + 1.0 / 39 * sin(34 * t + 19.0 / 12) + 1.0 / 9 * sin(36 * t + 38.0 / 25) + 1.0 / 38 * sin(39 * t + 9.0 / 5) + 1.0 / 5 * sin(40 * t + 47.0 / 10) + 1.0 / 17 * sin(41 * t + 55.0 / 12) + 1.0 / 17 * sin(42 * t + 8.0 / 5) + 1.0 / 17 * sin(47 * t + 14.0 / 9) + 1.0 / 21 * sin(51 * t + 13.0 / 7) + 1.0 / 22 * sin(52 * t + 11.0 / 6) + 1.0 / 17 * sin(53 * t + 2) + 2.0 / 9 * sin(54 * t + 5.0 / 3) + 1.0 / 7 * sin(55 * t + 51.0 / 11) + 1.0 / 7 * sin(56 * t + 19.0 / 12) + 1.0 / 22 * sin(58 * t + 13.0 / 8) + 1.0 / 16 * sin(61 * t + 18.0 / 11) + 1.0 / 47 * sin(65 * t + 5.0 / 3) + 1.0 / 14 * sin(66 * t + 19.0 / 11) + 1.0 / 15 * sin(67 * t + 51.0 / 11) + 1.0 / 14 * sin(68 * t + 22.0 / 13) + 1.0 / 80 * sin(75 * t + 49.0 / 11) + 1.0 / 13 * sin(80 * t + 17.0 / 10) + 136.0 / 11) * theta(15 * EIGEN_PI - t) * theta(t - 11 * EIGEN_PI) + (-1.0 / 33 * sin(4.0 / 3 - 80 * t) - 1.0 / 17 * sin(10.0 / 7 - 72 * t) - 1.0 / 16 * sin(11.0 / 9 - 71 * t) - 1.0 / 10 * sin(7.0 / 5 - 70 * t) - 1.0 / 57 * sin(19.0 / 14 - 68 * t) - 1.0 / 16 * sin(13.0 / 9 - 65 * t) - 1.0 / 10 * sin(3.0 / 2 - 61 * t) - 1.0 / 16 * sin(22.0 / 15 - 54 * t) - 1.0 / 14 * sin(38.0 / 25 - 45 * t) - 1.0 / 6 * sin(11.0 / 7 - 43 * t) - 1.0 / 5 * sin(3.0 / 2 - 41 * t) - 1.0 / 9 * sin(11.0 / 8 - 32 * t) - 5.0 / 13 * sin(3.0 / 2 - 31 * t) - 3.0 / 8 * sin(3.0 / 2 - 27 * t) - 3.0 / 5 * sin(23.0 / 15 - 25 * t) - 5.0 / 7 * sin(23.0 / 15 - 15 * t) - 1.0 / 11 * sin(29.0 / 19 - 5 * t) - 134.0 / 13 * sin(11.0 / 7 - t) + 3.0 / 4 * sin(2 * t + 11.0 / 7) + 5.0 / 9 * sin(3 * t + 13.0 / 8) + 33.0 / 34 * sin(4 * t + 11.0 / 7) + 2.0 / 3 * sin(6 * t + 8.0 / 5) + 5.0 / 6 * sin(7 * t + 8.0 / 5) + 9.0 / 17 * sin(8 * t + 8.0 / 5) + 4.0 / 5 * sin(9 * t + 21.0 / 13) + 3.0 / 2 * sin(10 * t + 8.0 / 5) + 1.0 / 5 * sin(11 * t + 14.0 / 9) + 1.0 / 9 * sin(12 * t + 22.0 / 13) + 8.0 / 11 * sin(13 * t + 18.0 / 11) + 1.0 / 43 * sin(14 * t + 13.0 / 8) + 5.0 / 4 * sin(16 * t + 13.0 / 8) + 18.0 / 7 * sin(17 * t + 13.0 / 8) + 3.0 / 5 * sin(18 * t + 5.0 / 3) + 9.0 / 5 * sin(19 * t + 13.0 / 8) + 1.0 / 4 * sin(20 * t + 12.0 / 7) + 10.0 / 19 * sin(21 * t + 5.0 / 3) + 5.0 / 8 * sin(22 * t + 18.0 / 11) + 1.0 / 8 * sin(23 * t + 23.0 / 5) + 1.0 / 5 * sin(24 * t + 14.0 / 9) + 1.0 / 7 * sin(26 * t + 19.0 / 12) + 1.0 / 16 * sin(28 * t + 6.0 / 5) + 1.0 / 54 * sin(29 * t + 31.0 / 7) + 1.0 / 4 * sin(30 * t + 8.0 / 5) + 1.0 / 85 * sin(33 * t + 24.0 / 7) + 1.0 / 6 * sin(34 * t + 18.0 / 11) + 1.0 / 9 * sin(35 * t + 16.0 / 9) + 4.0 / 13 * sin(36 * t + 23.0 / 14) + 1.0 / 23 * sin(37 * t + 68.0 / 15) + 5.0 / 14 * sin(38 * t + 23.0 / 14) + 1.0 / 8 * sin(39 * t + 15.0 / 8) + 3.0 / 8 * sin(40 * t + 5.0 / 3) + 1.0 / 55 * sin(42 * t + 9.0 / 10) + 1.0 / 49 * sin(44 * t + 7.0 / 6) + 3.0 / 11 * sin(46 * t + 22.0 / 13) + 1.0 / 7 * sin(47 * t + 7.0 / 4) + 1.0 / 59 * sin(49 * t + 61.0 / 13) + 1.0 / 41 * sin(50 * t + 28.0 / 17) + 1.0 / 41 * sin(51 * t + 9.0 / 2) + 1.0 / 9 * sin(52 * t + 23.0 / 13) + 1.0 / 28 * sin(53 * t + 13.0 / 7) + 1.0 / 6 * sin(55 * t + 7.0 / 4) + 1.0 / 6 * sin(56 * t + 16.0 / 9) + 1.0 / 9 * sin(57 * t + 9.0 / 5) + 2.0 / 11 * sin(58 * t + 5.0 / 3) + 1.0 / 34 * sin(59 * t + 59.0 / 14) + 1.0 / 7 * sin(60 * t + 19.0 / 11) + 1.0 / 14 * sin(62 * t + 21.0 / 13) + 1.0 / 53 * sin(63 * t + 20.0 / 9) + 1.0 / 15 * sin(64 * t + 23.0 / 14) + 1.0 / 34 * sin(69 * t + 22.0 / 13) + 1.0 / 13 * sin(73 * t + 9.0 / 5) + 1.0 / 13 * sin(74 * t + 9.0 / 5) + 1.0 / 20 * sin(75 * t + 7.0 / 4) + 1.0 / 11 * sin(76 * t + 16.0 / 9) + 1.0 / 30 * sin(77 * t + 2) + 403.0 / 10) * theta(11 * EIGEN_PI - t) * theta(t - 7 * EIGEN_PI) + (-1.0 / 3 * sin(7.0 / 13 - 4 * t) - 7.0 / 9 * sin(25.0 / 26 - 2 * t) + 229.0 / 12 * sin(t + 36.0 / 11) + 9.0 / 10 * sin(3 * t + 38.0 / 15) + 3.0 / 10 * sin(5 * t + 20.0 / 9) + 361.0 / 9) * theta(7 * EIGEN_PI - t) * theta(t - 3 * EIGEN_PI) + (-5.0 / 8 * sin(7.0 / 10 - 4 * t) - 6.0 / 7 * sin(7.0 / 12 - 2 * t) + 673.0 / 32 * sin(t + 28.0 / 9) + 8.0 / 9 * sin(3 * t + 20.0 / 7) + 191.0 / 16) * theta(3 * EIGEN_PI - t) * theta(t + EIGEN_PI)) * theta(sqrt(sgn(sin(t / 2))));
        return y_t+550.0;
    }

    IKSystem::Vec3ArrPtr IKSystem::BuildCustomTargetPosition() {
        // get function from https://www.wolframalpha.com/input/?i=Albert+Einstein+curve
        // int nums = 5000;
        // using Vec3Arr = std::vector<glm::vec3>;
        // std::shared_ptr<Vec3Arr> custom(new Vec3Arr(nums));
        // int index = 0;
        // for (int i = 0; i < nums; i++) {
        //    float x_val = 1.5e-3f * custom_x(92 * glm::pi<float>() * i / nums);
        //    float y_val = 1.5e-3f * custom_y(92 * glm::pi<float>() * i / nums);
        //    if (std::abs(x_val) < 1e-3 || std::abs(y_val) < 1e-3) continue;
        //    (*custom)[index++] = glm::vec3(1.6f - x_val, 0.0f, y_val - 0.2f);
        //}
        // custom->resize(index);
        // return custom;

         //int nums      = 5000;
         //using Vec3Arr = std::vector<glm::vec3>;
         //std::shared_ptr<Vec3Arr> custom(new Vec3Arr(nums));
         //int                      index = 0;
         //for (int i = 0; i < nums; i++) {
         //    float x_val = 1.5e-3f * doge_custom_x(92 * glm::pi<float>() * i / nums);
         //    float y_val = 1.5e-3f * doge_custom_y(92 * glm::pi<float>() * i / nums);
         //    if (std::abs(x_val) < 1e-3 || std::abs(y_val) < 1e-3) continue;
         //    (*custom)[index++] = glm::vec3(1.6f - x_val, 0.0f, y_val - 0.2f);
         //}
         //custom->resize(index);
         //return custom;

        int nums      = 50;
        using Vec3Arr = std::vector<glm::vec3>;
        std::shared_ptr<Vec3Arr> custom(new Vec3Arr(nums*12));
        int                      index = 0;


        // X
        for (int i = 0; i < nums; i++) {
            float x_val        = 0.4 * i / nums;
            float y_val        = 0.4*i/nums;
            (*custom)[index++] = glm::vec3(x_val+1.35, 0.0f, y_val);
        }
        for (int i = 0; i < nums; i++) {
            float x_val        = 0.4 * i / nums;
            float y_val        = 0.4-0.4 * i / nums;
            (*custom)[index++] = glm::vec3(x_val+1.35, 0.0f, y_val);
        }
         
        // T
        for (int i = 0; i < nums; i++) {
            float x_val        = 0.4 * i / nums;
            float y_val        = 0.4;
            (*custom)[index++] = glm::vec3(x_val+0.85, 0.0f, y_val);
        }
        for (int i = 0; i < nums; i++) {
            float x_val        = 0.2;
            float y_val        = 0.4 * i / nums;
            (*custom)[index++] = glm::vec3(x_val+0.85, 0.0f, y_val);
        }
         //R
         for (int i = 0; i < nums; i++) {
            float x_val        = 0.2;
            float y_val        = 0.4 * i / nums;
            (*custom)[index++] = glm::vec3(x_val+0.5, 0.0f, y_val);
        }
         for (int i = 0; i < nums; i++) {
            float x_val        = 0.2 - 0.2 * sin(EIGEN_PI * i / nums);
             float y_val        = 0.3+0.1 * cos(EIGEN_PI* i / nums);
             (*custom)[index++] = glm::vec3(x_val+0.5, 0.0f, y_val);
         }
         for (int i = 0; i < nums; i++) {
             float x_val        = 0.2-0.2*i/nums;
             float y_val        = 0.2-0.2*i/nums;
             (*custom)[index++] = glm::vec3(x_val+0.5, 0.0f, y_val);
         }
        // Y
         for (int i = 0; i < nums; i++) {
             float x_val        = 0.15;
             float y_val        = 0.25*i/nums;
             (*custom)[index++] = glm::vec3(x_val+0.05, 0.0f, y_val);
         }
         for (int i = 0; i < nums; i++) {
             float x_val        = 0.15+0.15*i/nums;
             float y_val        = 0.25+0.15 * i / nums;
             (*custom)[index++] = glm::vec3(x_val+0.05, 0.0f, y_val);
         }
         for (int i = 0; i < nums; i++) {
             float x_val        = 0.15 - 0.15 * i / nums;
             float y_val        = 0.25 + 0.15 * i / nums;
             (*custom)[index++] = glm::vec3(x_val+0.05, 0.0f, y_val);
         }
        custom->resize(index);
        return custom;
    }

    static Eigen::VectorXf glm2eigen(std::vector<glm::vec3> const & glm_v) {
        Eigen::VectorXf v = Eigen::Map<Eigen::VectorXf const, Eigen::Aligned>(reinterpret_cast<float const *>(glm_v.data()), static_cast<int>(glm_v.size() * 3));
        return v;
    }

    static std::vector<glm::vec3> eigen2glm(Eigen::VectorXf const & eigen_v) {
        return std::vector<glm::vec3>(
            reinterpret_cast<glm::vec3 const *>(eigen_v.data()),
            reinterpret_cast<glm::vec3 const *>(eigen_v.data() + eigen_v.size())
        );
    }

    static Eigen::SparseMatrix<float> CreateEigenSparseMatrix(std::size_t n, std::vector<Eigen::Triplet<float>> const & triplets) {
        Eigen::SparseMatrix<float> matLinearized(n, n);
        matLinearized.setFromTriplets(triplets.begin(), triplets.end());
        return matLinearized;
    }

    // solve Ax = b and return x
    static Eigen::VectorXf ComputeSimplicialLLT(
        Eigen::SparseMatrix<float> const & A,
        Eigen::VectorXf const & b) {
        auto solver = Eigen::SimplicialLLT<Eigen::SparseMatrix<float>>(A);
        return solver.solve(b);
    }


    float eval_g(MassSpringSystem & system, Eigen::VectorXf & x_vec, Eigen::VectorXf & y_vec,float ddt)
    {
        Eigen::VectorXf tmp_vec = x_vec-y_vec;
        float           eval_g_ret = ((tmp_vec * system.Mass).dot(tmp_vec))/ (2.0f*ddt * ddt);
        for (auto const spring : system.Springs)
        {
            
            auto const p0 = spring.AdjIdx.first;
            auto const p1 = spring.AdjIdx.second;
            if (system.Fixed[p0] && system.Fixed[p1]) continue;

            glm::vec3 const x01 = system.Positions[p1] - system.Positions[p0];
            float           deta_length = glm::length(x01) - spring.RestLength;
            float           tmp_E = 1.0f / 2.0f * system.Stiffness * deta_length*deta_length;
            eval_g_ret += tmp_E;
        }
        return eval_g_ret;
    }

    Eigen::VectorXf eval_intern_f(MassSpringSystem & system, Eigen::VectorXf & x_vec)
    {
        std::vector<glm::vec3> forces(system.Positions.size(), glm::vec3(0));
        std::vector<glm::vec3> x_vec3 = eigen2glm(x_vec);
        for (auto const spring : system.Springs) {
            auto const      p0  = spring.AdjIdx.first;
            auto const      p1  = spring.AdjIdx.second;
            if (system.Fixed[p0] && system.Fixed[p1]) continue;
            glm::vec3 const x01 = x_vec3[p1] - x_vec3[p0]; // use updated x_vec

            glm::vec3 const e01 = glm::normalize(x01);
            glm::vec3       f   = (system.Stiffness * (glm::length(x01) - spring.RestLength)) * e01;
            forces[p0] += f;
            forces[p1] -= f;
        }
        return glm2eigen(forces);
    }
    Eigen::VectorXf eval_grad_g(MassSpringSystem & system, Eigen::VectorXf & x_vec, Eigen::VectorXf & y_vec, float ddt)
    {
        Eigen::VectorXf grad_g_ret = system.Mass * (x_vec - y_vec) / (ddt*ddt);
        grad_g_ret -= eval_intern_f(system,x_vec);
        return grad_g_ret;
    }

    void eval_grad2_g(MassSpringSystem & system, Eigen::VectorXf & x_vec, float ddt, Eigen::SparseMatrix<float> & dst_matrix)
    {
        int pos_num = system.Positions.size();

        Eigen::SparseMatrix<float> grad2_g_ret(3 * pos_num, 3 * pos_num);

        // M Matrix
        std::vector<Eigen::Triplet<float>> m_triplets;
        float                              tmp_m = system.Mass / (ddt * ddt);
        for (int i = 0; i < 3*pos_num; i++)
        {
            m_triplets.emplace_back(i, i,tmp_m);
        }
        Eigen::SparseMatrix<float> m_mat = CreateEigenSparseMatrix(size_t(3) * pos_num,m_triplets);

        // Hessian Matrix
        std::vector<Eigen::Triplet<float>> Hessian_triplets;
        std::vector<glm::vec3>             x_vec3 = eigen2glm(x_vec);
        for (auto const spring : system.Springs) {
            auto const p0 = spring.AdjIdx.first;
            auto const p1 = spring.AdjIdx.second;
            if (system.Fixed[p0] && system.Fixed[p1]) continue;
            glm::vec3 const x01 = x_vec3[p1] - x_vec3[p0];

            float len_x01 = glm::length(x01);

            glm::mat3 identity_matrix {1.0f};
            //printf("%f %f %f\n", identity_matrix[0][0], identity_matrix[1][1], identity_matrix[2][2]);
            
            glm::mat3 x_matrix(0.0f);

            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    x_matrix[i][j] = x01[i] * x01[j];
                }
            }

            glm::mat3 hessian_tmp_matrix = x_matrix / (len_x01*len_x01);
            hessian_tmp_matrix += (1.0f - spring.RestLength / len_x01) * (identity_matrix - x_matrix/(len_x01*len_x01));
            hessian_tmp_matrix *= system.Stiffness;

            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    Hessian_triplets.emplace_back(p0 * 3 + i, p0 * 3 + j, hessian_tmp_matrix[i][j]); //Warning: from size_t to 
                    Hessian_triplets.emplace_back(p1 * 3 + i, p1 * 3 + j, hessian_tmp_matrix[i][j]);
                    Hessian_triplets.emplace_back(p0 * 3 + i, p1 * 3 + j, -hessian_tmp_matrix[i][j]);
                    Hessian_triplets.emplace_back(p1 * 3 + i, p0 * 3 + j, -hessian_tmp_matrix[i][j]);
                }
            }

        }

        Eigen::SparseMatrix<float> Hessian_mat = CreateEigenSparseMatrix(3 * pos_num, Hessian_triplets);

        dst_matrix = m_mat+Hessian_mat;
    }

    void AdvanceMassSpringSystem(MassSpringSystem & system, float const dt) {
        //// your code here: rewrite following code
        //int const steps = 1000;
        //float const ddt = dt / steps; 
        //for (std::size_t s = 0; s < steps; s++) {
        //    std::vector<glm::vec3> forces(system.Positions.size(), glm::vec3(0));
        //    for (auto const spring : system.Springs) {
        //        auto const p0 = spring.AdjIdx.first;
        //        auto const p1 = spring.AdjIdx.second;
        //        glm::vec3 const x01 = system.Positions[p1] - system.Positions[p0];
        //        glm::vec3 const v01 = system.Velocities[p1] - system.Velocities[p0];
        //        glm::vec3 const e01 = glm::normalize(x01);
        //        glm::vec3 f = (system.Stiffness * (glm::length(x01) - spring.RestLength)) * e01;
        //        forces[p0] += f;
        //        forces[p1] -= f;
        //    }
        //    for (std::size_t i = 0; i < system.Positions.size(); i++) {
        //        if (system.Fixed[i]) continue;
        //        system.Velocities[i] += (glm::vec3(0, -system.Gravity, 0) + forces[i] / system.Mass) * ddt;
        //        system.Positions[i] += system.Velocities[i] * ddt;
        //    }
        //}

        // your code here: rewrite following code
        // Implicit Euler algorithm
        // x_{k+1}=x_{k}+ddt*v_{k+1}
        // v_{k+1}=v_{k}+ddt*F(x_{k+1})/M
        int const   steps = 1;
        float const ddt   = dt / steps;
        // without extern iterations
        for (std::size_t s = 0; s < steps; s++) {
            int pos_num = system.Positions.size();
            // initialize
            Eigen::VectorXf x0    = glm2eigen(system.Positions);
            Eigen::VectorXf v0 = glm2eigen(system.Velocities);
            Eigen::VectorXf f0_extern_grav = glm2eigen(std::vector<glm::vec3>(system.Positions.size(), glm::vec3(0, -system.Gravity, 0)));
            Eigen::VectorXf system_m_vectorxf = glm2eigen(std::vector<glm::vec3>(system.Positions.size(), glm::vec3(system.Mass,system.Mass,system.Mass)));

            Eigen::VectorXf y0 = x0 + ddt * (v0 + ddt * f0_extern_grav);
          

            Eigen::VectorXf  grad_g = eval_grad_g(system, x0, y0, ddt);
            Eigen::SparseMatrix<float> grad2_g(3 * pos_num, 3 * pos_num);
            eval_grad2_g(system, x0, ddt, grad2_g);

            Eigen::VectorXf x1_x0 = ComputeSimplicialLLT(grad2_g, -grad_g);


            Eigen::VectorXf  final_x   = x1_x0 + x0;
            std::vector<glm::vec3> final_x_vec3 = eigen2glm(final_x);
            std::vector<glm::vec3> final_v = eigen2glm(v0 + ddt * (eval_intern_f(system,final_x)/system.Mass + f0_extern_grav));

            for (std::size_t i = 0; i < system.Positions.size(); i++) {
                if (system.Fixed[i]) continue;
                system.Velocities[i] = final_v[i];
                system.Positions[i]  = final_x_vec3[i];
            }

        }


    }

}
